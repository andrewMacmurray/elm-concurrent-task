[{"name":"Concurrent.Task","comment":" A Task similar to `elm/core`'s `Task` but:\n\n  - Allows concurrent execution of `map2`, `map3`, ...\n  - Can safely call external JavaScript and chain the results (also known as Task Ports).\n\n\n## Built-in Tasks\n\nBecause `elm-concurrent-task` uses a different type to `elm/core` `Task` it's unfortunately not compatible with `elm/core` `Task`s.\n\nHowever, there are a number of tasks built into the JavaScript runner and supporting modules that should cover a large amount of the existing functionality of `elm/core` `Task`s.\n\nCheck out the built-ins for more details:\n\n  - [`Http.request`](Concurrent-Task-Http)\n  - [`Process.sleep`](Concurrent-Task-Process)\n  - [`Random.generate`](Concurrent-Task-Random)\n  - [`Time.now`](Concurrent-Task-Time)\n\n\n# Tasks\n\nA `Task` represents an asynchronous unit of work with the possibility of failure.\n\nUnderneath, each task represents a call to a JavaScript function and the runner handles batching and sequencing the calls.\n\n@docs Task, define\n\n\n# Expectations\n\nDecode the response of a JS function into an Elm value.\n\n@docs Expect, expectJson, expectString, expectWhatever\n\n\n# Error Handling\n\n`Error` handlers provide different ways to capture errors for a `Task`.\n\n\n## Understanding Errors\n\n`Concurrent.Task` has two main kinds of `Errors`:\n\n\n## TaskError\n\nThis is the `x` in the `Task x a` and represents an **expected error** as part of your task flow.\nYou can handle these with [mapError](Concurrent-Task#mapError) and [onError](Concurrent-Task#onError).\n\n\n## RunnerError\n\nYou can think of these as **unhandled** errors that are not a normal part of your task flow.\n\nThe idea behind `RunnerError` is to keep your task flow types `Task x a` clean and meaningful,\nand optionally lift some of them into your `TaskError` type where it makes sense\n\nSee the section on [RunnerError](Concurrent-Task#RunnerError)s for more details.\n\n\n## Handling Runner Errors\n\nSome of these can be captured as regular `TaskErrors` (The `x` in `Task x a`) using handlers:\n\n  - `UnhandledJsException` - can be converted into a regular `TaskError` with [expectThrows](Concurrent-Task#expectThrows).\n  - `UnhandledJsException` - can be converted into a `Success` with [catchAll](Concurrent-Task#catchAll).\n  - `ResponseDecoderFailure` - can be lifted into regular task flow with [onResponseDecoderFailure](Concurrent-Task#onResponseDecoderFailure).\n\n\n## Fatal Errors\n\nSome `RunnerError`s cannot be caught, these are assumed to have no meaningful way to recover from:\n\n  - `MissingFunction` will always be thrown if there is a mismatch between JS and Elm function names.\n  - `ErrorsDecoderFailure` will always be thrown if a returned error didn't match a provided [expectErrors](Concurrent-Task#expectErrors) decoder.\n\n@docs Errors, expectThrows, expectErrors, catchAll, onResponseDecoderFailure\n\n\n# Transforming Errors\n\n@docs mapError, onError\n\n\n# Chaining Tasks\n\n@docs succeed, fail, andThen\n\n\n# Convenience Helpers\n\nThese are some general helpers that can make chaining and combining tasks more convenient.\n\n@docs fromResult, andThenDo, return\n\n\n# Bulk Helpers\n\nWhen you need to combine many tasks together.\n\n\n## Stack Safety\n\nThese helpers are carefully written to be stack safe. Use them if you're handling large lists of tasks (> 2000).\n\n@docs batch, sequence\n\n\n# Maps\n\nTransform values returned from tasks.\n\n@docs map, andMap, map2, map3, map4, map5\n\n\n# Run a Task\n\nOnce you've constructed a Task it needs to be passed to the runner to perform all of the effects.\n\nHere's a minimal complete example:\n\n\n## A task to fetch 3 resources concurrently:\n\n    type alias Titles =\n        { todo : String\n        , post : String\n        , album : String\n        }\n\n    getAllTitles : Task Http.Error Titles\n    getAllTitles =\n        Task.map3 Titles\n            (getTitle \"/todos/1\")\n            (getTitle \"/posts/1\")\n            (getTitle \"/albums/1\")\n\n    getTitle : String -> Task Http.Error String\n    getTitle path =\n        Http.request\n            { url = \"https://jsonplaceholder.typicode.com\" ++ path\n            , method = \"GET\"\n            , headers = []\n            , body = Http.emptyBody\n            , expect = Http.expectJson (Decode.field \"title\" Decode.string)\n            }\n\n\n## A program to run the task:\n\n    port module Example exposing (main)\n\n    import Concurrent.Task as Task exposing (Task)\n    import Concurrent.Task.Http as Http\n    import Json.Decode as Decode\n\n    type alias Model =\n        { tasks : Task.Pool Msg Http.Error Titles\n        }\n\n    type Msg\n        = OnProgress ( Task.Pool Msg Http.Error Titles, Cmd Msg )\n        | OnComplete (Task.Response Http.Error Titles)\n\n    init : ( Model, Cmd Msg )\n    init =\n        let\n            ( tasks, cmd ) =\n                Task.attempt\n                    { send = send\n                    , pool = Task.pool\n                    , onComplete = OnComplete\n                    }\n                    getAllTitles\n        in\n        ( { tasks = tasks }, cmd )\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg model =\n        case msg of\n            OnComplete response ->\n                let\n                    _ =\n                        Debug.log \"response\" response\n                in\n                ( model, Cmd.none )\n\n            OnProgress ( tasks, cmd ) ->\n                ( { model | tasks = tasks }, cmd )\n\n    subscriptions : Model -> Sub Msg\n    subscriptions model =\n        Task.onProgress\n            { send = send\n            , receive = receive\n            , onProgress = OnProgress\n            }\n            model.tasks\n\n    port send : Decode.Value -> Cmd msg\n\n    port receive : (Decode.Value -> msg) -> Sub msg\n\n    main : Program {} Model Msg\n    main =\n        Platform.worker\n            { init = always init\n            , update = update\n            , subscriptions = subscriptions\n            }\n\n@docs attempt, Response, RunnerError, onProgress, Pool, pool\n\n","unions":[{"name":"Response","comment":" The value returned from a task when it completes (returned in the `OnComplete` msg).\n\nCan be either:\n\n  - `Success a` - the task succeeded with no errors, woo!\n  - `TaskError x` - the task failed with an expected error.\n  - `RunnerError` - the task failed with an unexpected error (see the section on `Error Handling` for more details).\n\n","args":["x","a"],"cases":[["Success",["a"]],["TaskError",["x"]],["RunnerError",["Concurrent.Task.RunnerError"]]]},{"name":"RunnerError","comment":" An error returned from the runner if something **unexpected** has happened during the task flow.\n\nThese errors will be returned **if not handled** during task flow:\n\n  - `UnhandledJsException` - a task threw an exception and was not caught with an error handler (can be caught with `expectThrows` and `catchAll`).\n  - `ResponseDecoderFailure` - a task returned an unexpected response (can be caught with `onResponseDecoderFailure`).\n\nThese errors will **always surface**, as they are assumed to have no meaningful way to recover from during regular task flow:\n\n  - `ErrorsDecoderFailure` - a task returned error data in an unexpected format.\n  - `MissingFunction` - a task tried to call a function in the JS runner which was not registered.\n  - `InternalError` - something went wrong with the runner internals - this should not happen, but if you see this error [please leave details and an issue](https://github.com/andrewMacmurray/elm-concurrent-task/issues/new).\n\n","args":[],"cases":[["UnhandledJsException",["{ function : String.String, message : String.String }"]],["ResponseDecoderFailure",["{ function : String.String, error : Json.Decode.Error }"]],["ErrorsDecoderFailure",["{ function : String.String, error : Json.Decode.Error }"]],["MissingFunction",["String.String"]],["InternalError",["String.String"]]]}],"aliases":[{"name":"Errors","comment":" A handler passed to `Task.define`.\n","args":["x","a"],"type":"Concurrent.Internal.Task.Errors x a"},{"name":"Expect","comment":" ","args":["a"],"type":"Concurrent.Internal.Task.Expect a"},{"name":"Pool","comment":" ","args":["msg","x","a"],"type":"Concurrent.Internal.Task.Pool msg x a"},{"name":"Task","comment":" ","args":["x","a"],"type":"Concurrent.Internal.Task.Task x a"}],"values":[{"name":"andMap","comment":" Combine an arbitrary number of tasks together concurrently.\n\nMaybe you want to load multiple pieces of config into a record:\n\n    import Concurrent.Task as Task exposing (Task)\n\n    type alias Config =\n        { dbConfig : DbConfig\n        , yamlConfig : YamlConfig\n        , envFile : EnvFile\n        }\n\n     loadConfig : Task Error Config\n     loadConfig =\n        Task.succeed Config\n            |> Task.andMap loadDbConfig\n            |> Task.andMap loadYamlConfig\n            |> Task.andMap loadEnvFile\n\n","type":"Concurrent.Task.Task x a -> Concurrent.Task.Task x (a -> b) -> Concurrent.Task.Task x b"},{"name":"andThen","comment":" Chain the successful result of the previous Task into another one.\n\nMaybe you want to do a timestamped Http request\n\n    import Concurrent.Task as Task exposing (Task)\n    import Concurrent.Task.Http as Http\n    import Concurrent.Task.Time\n    import Time\n\n    task : Task Http.Error String\n    task =\n        Concurrent.Task.Time.now\n            |> Task.andThen (createArticle \"my article\")\n\n    createArticle : String -> Time.Posix -> Task Http.Error String\n    createArticle title time =\n        Http.request\n            { url = \"http://blog.com/articles\"\n            , method = \"POST\"\n            , headers = []\n            , expect = Http.expectString\n            , body = Http.jsonBody (encodeArticle title time)\n            }\n\n","type":"(a -> Concurrent.Task.Task x b) -> Concurrent.Task.Task x a -> Concurrent.Task.Task x b"},{"name":"andThenDo","comment":" Similar to `andThen` but ignores the successful result of the previous Task.\n\nMaybe you want to save a file then log a message to the console:\n\n    import Concurrent.Task as Task exposing (Task)\n\n    task : Task Error ()\n    task =\n        saveFile |> Task.andThenDo (log \"file saved\")\n\n","type":"Concurrent.Task.Task x b -> Concurrent.Task.Task x a -> Concurrent.Task.Task x b"},{"name":"attempt","comment":" Start a Task.\n\nThis needs:\n\n  - A task `Pool` (The internal model to keep track of task progress).\n  - The `send` port.\n  - The `Msg` to be called when the task completes.\n  - Your `Task` to be run.\n\nMake sure to update your `Model` and pass in the `Cmd` returned from `attempt`. e.g. in a branch of `update`:\n\n    let\n        ( tasks, cmd ) =\n            Task.attempt\n                { send = send\n                , pool = model.pool\n                , onComplete = OnComplete\n                }\n                myTask\n    in\n    ( { model | tasks = tasks }, cmd )\n\n","type":"{ pool : Concurrent.Task.Pool msg x a, send : Json.Decode.Value -> Platform.Cmd.Cmd msg, onComplete : Concurrent.Task.Response x a -> msg } -> Concurrent.Task.Task x a -> ( Concurrent.Task.Pool msg x a, Platform.Cmd.Cmd msg )"},{"name":"batch","comment":" Perform a List of tasks concurrently (similar to `Promise.all()` in JavaScript) and return the results in a List.\n\nIf any of the subtasks fail the whole Task will fail.\n\n","type":"List.List (Concurrent.Task.Task x a) -> Concurrent.Task.Task x (List.List a)"},{"name":"catchAll","comment":" Using this handler transforms any `JS Exceptions` or `ResponseDecoderFailures` into a `Success` with the provided fallback.\n\nOnly use this handler for functions that can't fail.\n\ne.g. logging to the console:\n\n    import Concurrent.Task as Task exposing (Task)\n\n    log : String -> Task x ()\n    log msg =\n        Task.define\n            { function = \"console:log\"\n            , expect = Task.expectWhatever ()\n            , errors = Task.catchAll ()\n            , args = Encode.string msg\n            }\n\nOn the JS side:\n\n    Tasks.register({\n      tasks: {\n        \"console:log\": (msg) => console.log(msg),\n      },\n      ports: {\n        send: app.ports.send,\n        receive: app.ports.receive,\n      },\n    });\n\n","type":"a -> Concurrent.Task.Errors x a"},{"name":"define","comment":" Define a `Task` from an external JavaScript function with:\n\n  - The `name` of the registered function you want to call.\n  - What you `expect` to come back from the function when it returns.\n  - How to interpret `errors` coming from the function (exceptions or explicitly returned errors).\n  - The encoded `args` to pass to the function.\n\nSay you wanted to interact with the node filesystem:\n\nDefine your task in `Elm`:\n\n    import Concurrent.Task as Task exposing (Task)\n    import Json.Encode as Encode\n\n    type Error\n        = Error String\n\n    readFile : String -> Task Error String\n    readFile path =\n        Task.define\n            { function = \"fs:readFile\"\n            , expect = Task.expectString\n            , errors = Task.expectThrows Error\n            , args = Encode.object [ ( \"path\", Encode.string path ) ]\n            }\n\nAnd in your `JavaScript` runner:\n\n    import * as fs from \"node:fs/promises\"\n    import * as Tasks from \"@andrewMacmurray/elm-concurrent-task\";\n\n\n    const app = Elm.Main.init({});\n\n    Tasks.register({\n      tasks: {\n        \"fs:readFile\": (args) => fs.readFile(args.path),\n      },\n      ports: {\n        send: app.ports.send,\n        receive: app.ports.receive,\n      },\n    });\n\n\n## A note on Errors:\n\nThe example `fs:readFile` Task has very simple error handling (turn any thrown exceptions into the Error type).\nThis can be a great way to start, but what if you want more detailed errors?\n\nThe `Errors` section goes into more detail on different error handling strategies, including:\n\n  - how to define and handle more meaningful error types.\n  - bypassing all errors for Tasks which never fail (e.g. get the current time, log to the console).\n  - handling unexpected return data (e.g. the function returns an `Int` when you were expecting a `String`).\n\n","type":"{ function : String.String, expect : Concurrent.Task.Expect a, errors : Concurrent.Task.Errors x a, args : Json.Encode.Value } -> Concurrent.Task.Task x a"},{"name":"expectErrors","comment":" Decode explicit errors returned by a Task. Use this when you want more meaningful errors in your task.\n\nThis will decode the value from an `error` key returned by a JS function, e.g.:\n\n    return {\n      error: {\n        code: \"MY_ERROR_CODE\",\n        message: \"Something Went Wrong\",\n      }\n    }\n\n**Important Notes**:\n\n  - If your function doesn't return an `\"error\"` key it will be interpreted as a success response.\n  - If your JS function throws an exception it will surface as a `RunnerError UnhandledJsException` -\n    make sure to catch these in your JS function and return them as structured error responses.\n  - If your error decoder fails the task will surface a `RunnerError ExpectErrorFailure`.\n\nMaybe you want to handle different kinds of errors when writing to `localStorage`:\n\n    import Concurrent.Task as Task exposing (Task)\n    import Json.Decode as Decode\n    import Json.Encode as Encode\n\n    type WriteError\n        = QuotaExceeded\n        | WriteBlocked\n\n    set : String -> String -> Task WriteError ()\n    set key value =\n        Task.define\n            { function = \"storage:set\"\n            , expect = Task.expectWhatever\n            , errors = Task.expectErrors decodeWriteError\n            , args =\n                Encode.object\n                    [ ( \"key\", Encode.string key )\n                    , ( \"value\", Encode.string value )\n                    ]\n            }\n\n    decodeWriteError : Decode.Decoder WriteError\n    decodeWriteError =\n        Decode.string\n            |> Decode.andThen\n                (\\reason ->\n                    case reason of\n                        \"QUOTA_EXCEEDED\" ->\n                            Decode.succeed QuotaExceeded\n\n                        \"WRITE_BLOCKED\" ->\n                            Decode.succeed WriteBlocked\n\n                        _ ->\n                            Decode.fail (\"Unknown WriteError Reason: \" ++ reason)\n                )\n\nAnd on the JS side:\n\n    Tasks.register({\n      tasks: {\n        \"storage:set\": (args) => setItem(args),\n      },\n      ports: {\n        send: app.ports.send,\n        receive: app.ports.receive,\n      },\n    });\n\n\n    function setItem(args) {\n      try {\n        localStorage.setItem(args.key, args.value);\n      } catch (e) {\n        if (e.name === \"QuotaExceededError\") {\n          return {\n            error: \"QUOTA_EXCEEDED\",\n          };\n        } else {\n          return {\n            error: \"WRITE_BLOCKED\",\n          };\n        }\n      }\n    }\n\n","type":"Json.Decode.Decoder x -> Concurrent.Task.Errors x a"},{"name":"expectJson","comment":" Run a JSON decoder on the response of a Task\n","type":"Json.Decode.Decoder a -> Concurrent.Task.Expect a"},{"name":"expectString","comment":" Expect the response of a Task to be a String\n","type":"Concurrent.Task.Expect String.String"},{"name":"expectThrows","comment":" The simplest Error handler. If a JS function throws an Exception, it will be wrapped in the provided `Error` type.\n\nMaybe your JS function throws an `AccessError`:\n\n    import Concurrent.Task as Task exposing (Task)\n\n    type Error\n        = MyError String\n\n    example : Task Error String\n    example =\n        Task.define\n            { function = \"functionThatThrows\"\n            , expect = Task.expectString\n            , errors = Task.expectThrows MyError\n            , args = Encode.null\n            }\n\nWhen the task is run it will complete with `Task.Error (MyError \"AccessError: access denied\")`.\nThis can be transformed and chained using `Task.mapError` and `Task.onError`.\n\n\n### Note:\n\nThis kind of error handling can be useful to get started quickly,\nbut it's often much more expressive and useful if you catch and explicitly return error data in your JS function that can be decoded with the `expectError` handler.\n\n","type":"(String.String -> x) -> Concurrent.Task.Errors x a"},{"name":"expectWhatever","comment":" Ignore the response of a Task\n","type":"Concurrent.Task.Expect ()"},{"name":"fail","comment":" A Task that fails immediately when it's run.\n","type":"x -> Concurrent.Task.Task x a"},{"name":"fromResult","comment":" Create a Task from a `Result error value`. The task will either immediately succeed or fail when run.\n\nMaybe you want to chain together tasks with CSV parsing:\n\n    import Concurrent.Task as Task exposing (Task)\n    import Csv\n\n    task : Task Error CsvData\n    task =\n        readFile |> Task.andThen parseCsv\n\n    parseCsv : String -> Task Error CsvData\n    parseCsv raw =\n        Csv.decode decoder raw\n            |> Task.fromResult\n            |> Task.mapError CsvError\n\n","type":"Result.Result x a -> Concurrent.Task.Task x a"},{"name":"map","comment":" Transform the value from a task.\n\nMaybe you want to find what time it is in one hour.\n\n    import Concurrent.Task as Task\n    import Concurrent.Task.Time\n    import Time\n\n    timeInOneHour : Task x Time.Posix\n    timeInOneHour =\n        Task.map addOneHour Concurrent.Task.Time.now\n\n    addOneHour : Time.Posix -> Time.Posix\n    addOneHour time =\n        Time.millisToPosix (Time.posixToMillis time + 60 * 60 * 1000)\n\n","type":"(a -> b) -> Concurrent.Task.Task x a -> Concurrent.Task.Task x b"},{"name":"map2","comment":" Run two tasks concurrently and combine their results.\n\n    import Concurrent.Task as Task exposing (Task)\n    import Concurrent.Task.Time\n    import Time\n\n    loadUserAndTime : Task Error ( User, Time.Posix )\n    loadUserAndTime =\n        Task.map2 Tuple.pair loadUser Concurrent.Task.Time.now\n\n","type":"(a -> b -> c) -> Concurrent.Task.Task x a -> Concurrent.Task.Task x b -> Concurrent.Task.Task x c"},{"name":"map3","comment":" Run three tasks concurrently and combine their results.\n","type":"(a -> b -> c -> d) -> Concurrent.Task.Task x a -> Concurrent.Task.Task x b -> Concurrent.Task.Task x c -> Concurrent.Task.Task x d"},{"name":"map4","comment":" Run four tasks concurrently and combine their results.\n","type":"(a -> b -> c -> d -> e) -> Concurrent.Task.Task x a -> Concurrent.Task.Task x b -> Concurrent.Task.Task x c -> Concurrent.Task.Task x d -> Concurrent.Task.Task x e"},{"name":"map5","comment":" Run five tasks concurrently and combine their results.\n","type":"(a -> b -> c -> d -> e -> f) -> Concurrent.Task.Task x a -> Concurrent.Task.Task x b -> Concurrent.Task.Task x c -> Concurrent.Task.Task x d -> Concurrent.Task.Task x e -> Concurrent.Task.Task x f"},{"name":"mapError","comment":" Transform the value of an Error (like `map` but for errors).\n","type":"(x -> y) -> Concurrent.Task.Task x a -> Concurrent.Task.Task y a"},{"name":"onError","comment":" If the previous Task fails, catch that error and return a new Task (like `andThen` but for errors).\n","type":"(x -> Concurrent.Task.Task y a) -> Concurrent.Task.Task x a -> Concurrent.Task.Task y a"},{"name":"onProgress","comment":" Subscribe to updates from the JavaScript task runner.\n\nThis needs:\n\n  - The `send` port.\n  - The `receive` port.\n  - The `Msg` to be called with the updated progress.\n  - The task `Pool` stored in your model.\n\nYou can wire this in like so:\n\n    subscriptions : Model -> Sub Msg\n    subscriptions model =\n        Task.onProgress\n            { send = send\n            , receive = receive\n            , onProgress = OnProgress\n            }\n            model.tasks\n\nMake sure to update your `Model` and pass in the `Cmd` in your `OnProgress` branch in `update`:\n\n    OnProgress ( tasks, cmd ) ->\n        ( { model | tasks = tasks }, cmd )\n\n","type":"{ send : Json.Decode.Value -> Platform.Cmd.Cmd msg, receive : (Json.Decode.Value -> msg) -> Platform.Sub.Sub msg, onProgress : ( Concurrent.Task.Pool msg x a, Platform.Cmd.Cmd msg ) -> msg } -> Concurrent.Task.Pool msg x a -> Platform.Sub.Sub msg"},{"name":"onResponseDecoderFailure","comment":" Use this alongside other error handlers to lift a `ResponseDecoderFailure`'s `Json.Decode` error into regular task flow.\n\nMaybe you want to represent an unexpected response as a `BadBody` error for a http request:\n\n    import Concurrent.Task as Task\n\n    type Error\n        = Timeout\n        | NetworkError\n        | BadStatus Int\n        | BadUrl String\n        | BadBody Decode.Error\n\n    request : Request a -> Task Error a\n    request options =\n        Task.define\n            { function = \"http:request\"\n            , expect = Task.expectJson options.expect\n            , errors = Task.expectErrors decodeHttpErrors\n            , args = encodeArgs options\n            }\n            |> Task.onResponseDecoderFailure (BadBody >> Task.fail)\n\n","type":"(Json.Decode.Error -> Concurrent.Task.Task x a) -> Concurrent.Task.Task x a -> Concurrent.Task.Task x a"},{"name":"pool","comment":" Create an empty Task Pool.\n\nThis is used to keep track of each Task's progress.\n\nRight now it doesn't expose any functionality, but it could be used in the future to do things like:\n\n  - Buffer the number of in-flight tasks (e.g. a server request queue, or database connection pool).\n  - Handle graceful process termination (e.g. abort or cleanup all in-flight tasks).\n  - Expose metrics on previous or running tasks.\n\n","type":"Concurrent.Task.Pool msg x a"},{"name":"return","comment":" Succeed with a hardcoded value after the previous Task\n\nMaybe you want to do some Tasks on a User but allow it to be chained onwards:\n\n    import Concurrent.Task as Task exposing (Task)\n\n    saveUser : User -> Task Error User\n    saveUser user =\n        saveToDatabase user\n            |> Task.andThenDo (log \"user saved\")\n            |> Task.return user\n\n","type":"b -> Concurrent.Task.Task x a -> Concurrent.Task.Task x b"},{"name":"sequence","comment":" Perform a List of tasks one after the other and return the results in a List.\n\nIf any of the subtasks fail the whole Task will fail.\n\n","type":"List.List (Concurrent.Task.Task x a) -> Concurrent.Task.Task x (List.List a)"},{"name":"succeed","comment":" A Task that succeeds immediately when it's run.\n","type":"a -> Concurrent.Task.Task x a"}],"binops":[]},{"name":"Concurrent.Task.Http","comment":" Make concurrent http requests.\n\nThe JavaScript runner has this task builtin by default.\nInternally It uses the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) which is widely supported in the Browser and (as of Node 18) in NodeJS.\n\nIf needed you can supply a custom implementation like so:\n\n    Tasks.register({\n      tasks: {},\n      ports: app.ports,\n      builtins: {\n        http: (request) => customHttp(request),\n      },\n    });\n\nSee the [typescript definitions](https://github.com/andrewMacmurray/elm-concurrent-task/blob/main/src/runner/http/index.ts) and the [fetch adapter](https://github.com/andrewMacmurray/elm-concurrent-task/blob/main/src/runner/http/fetch.ts) to see how to create your own.\n\n**Note:**\n\nYou're not required to use this module for http requests in `Concurrent.Task`, it's here for convenience.\nYou could create entirely your own from scratch - maybe you want an http package with request caching or special retry logic built in on the JS side.\n\n\n# Request\n\n@docs request\n\n\n# Body\n\nSend data in your http request.\n\n@docs Body, emptyBody, stringBody, jsonBody\n\n\n# Expect\n\nDescribe what you expect to be returned in an http response body.\n\n@docs Expect, expectJson, expectString, expectWhatever\n\n\n# Header\n\n@docs Header, header\n\n\n# Error\n\n@docs Error, Metadata\n\n","unions":[{"name":"Body","comment":" ","args":[],"cases":[]},{"name":"Error","comment":" A Request can fail in a couple ways:\n\n  - `BadUrl` means you did not provide a valid URL.\n  - `Timeout` means it took too long to get a response.\n  - `NetworkError` means the user turned off their wifi, went in a cave, etc.\n  - `BadStatus` means you got a response back, but the status code indicates failure.\n  - `BadBody` means you got a response back with a nice status code, but the body of the response was something unexpected.\n    The String in this case is a debugging message that explains what went wrong with your JSON decoder or whatever.\n\n","args":[],"cases":[["BadUrl",["String.String"]],["Timeout",[]],["NetworkError",[]],["BadStatus",["Concurrent.Task.Http.Metadata","Json.Decode.Value"]],["BadBody",["String.String"]]]},{"name":"Expect","comment":" ","args":["a"],"cases":[]}],"aliases":[{"name":"Header","comment":" An Http header for configuring a request.\n","args":[],"type":"( String.String, String.String )"},{"name":"Metadata","comment":" Extra information about the response:\n\n  - url of the server that actually responded (so you can detect redirects)\n  - statusCode like 200 or 404\n  - statusText describing what the statusCode means a little\n  - headers like Content-Length and Expires\n\n**Note:**\n\nIt is possible for a response to have the same header multiple times.\nIn that case, all the values end up in a single entry in the headers dictionary.\nThe values are separated by commas, following the rules outlined [here](https://stackoverflow.com/questions/4371328/are-duplicate-http-response-headers-acceptable).\n\n","args":[],"type":"{ url : String.String, statusCode : Basics.Int, statusText : String.String, headers : Dict.Dict String.String String.String }"}],"values":[{"name":"emptyBody","comment":" Create an empty body for your request.\nThis is useful for `GET` requests and `POST` requests where you are not sending any data.\n","type":"Concurrent.Task.Http.Body"},{"name":"expectJson","comment":" Expect the response body to be `JSON`, decode it using the supplied decoder.\n","type":"Json.Decode.Decoder a -> Concurrent.Task.Http.Expect a"},{"name":"expectString","comment":" Expect the response body to be a `String`.\n","type":"Concurrent.Task.Http.Expect String.String"},{"name":"expectWhatever","comment":" Discard the response body.\n","type":"Concurrent.Task.Http.Expect ()"},{"name":"header","comment":" Create a `Header`. e.g.:\n\n    header \"X-Requested-With\" \"Fetch\"\n\n","type":"String.String -> String.String -> Concurrent.Task.Http.Header"},{"name":"jsonBody","comment":" Put some JSON value in the body of your request. This will automatically add the `Content-Type: application/json` header.\n","type":"Json.Encode.Value -> Concurrent.Task.Http.Body"},{"name":"request","comment":" Send an Http request - similar to `elm/http`'s [`Http.Task`](https://package.elm-lang.org/packages/elm/http/latest/Http#task)\n","type":"{ url : String.String, method : String.String, headers : List.List Concurrent.Task.Http.Header, body : Concurrent.Task.Http.Body, expect : Concurrent.Task.Http.Expect a, timeout : Maybe.Maybe Basics.Int } -> Concurrent.Task.Task Concurrent.Task.Http.Error a"},{"name":"stringBody","comment":" Put a `String` in the body of your request. Defining `jsonBody` looks like this:\n\n    import Json.Encode as Encode\n\n    jsonBody : Encode.Value -> Body\n    jsonBody value =\n        stringBody \"application/json\" (Encode.encode 0 value)\n\nThe first argument is a [MIME type](https://en.wikipedia.org/wiki/Media_type) of the body.\n\n","type":"String.String -> String.String -> Concurrent.Task.Http.Body"}],"binops":[]},{"name":"Concurrent.Task.Process","comment":" A drop in replacement for [elm/core's](https://package.elm-lang.org/packages/elm/core/latest/Process#sleep) `Process.sleep`\n\nThe JavaScript runner has this task builtin by default. If needed it can be overridden like so:\n\n    Tasks.register({\n      tasks: {},\n      ports: app.ports,\n      builtins: {\n        sleep: (ms) => customSleep(ms)\n      }\n    });\n\n@docs sleep\n\n","unions":[],"aliases":[],"values":[{"name":"sleep","comment":" Wait for a number of milliseconds before continuing with the next Task\n","type":"Basics.Int -> Concurrent.Task.Task x ()"}],"binops":[]},{"name":"Concurrent.Task.Random","comment":" Generate random values based on an [elm/random](https://package.elm-lang.org/packages/elm/random/latest/Random#Generator) `Generator`\n\nThis Task uses a builtin randomSeed task from the JavaScript runner (the [same seed `elm/random` uses](https://github.com/elm/random/blob/ecf97bb43f0d5cd75243428f69f45323957bda25/src/Random.elm#L873-L875) - `Date.now()`).\n\nIf needed you can override the randomSeed task like so (e.g. use node or web crypto module to generate secure randomness):\n\n    Tasks.register({\n      tasks: {},\n      ports: app.ports,\n      builtins: {\n        randomSeed: () => crypto.getRandomValues(new Uint32Array(1))[0],\n      },\n    });\n\n@docs generate\n\n","unions":[],"aliases":[],"values":[{"name":"generate","comment":" Generate a random value based on an [elm/random](https://package.elm-lang.org/packages/elm/random/latest/Random) `Generator`\n","type":"Random.Generator a -> Concurrent.Task.Task x a"}],"binops":[]},{"name":"Concurrent.Task.Time","comment":" A drop in replacement for [elm/time's](https://package.elm-lang.org/packages/elm/time/latest/Time#now) `Time.now`\n\nThe JavaScript runner has this task builtin by default. If needed it can be overridden like so:\n\n    Tasks.register({\n      tasks: {},\n      ports: app.ports,\n      builtins: {\n        timeNow: () => customTimeNow(),\n      }\n    });\n\n@docs now\n\n","unions":[],"aliases":[],"values":[{"name":"now","comment":" Get the POSIX time at the moment when this task is run.\n","type":"Concurrent.Task.Task x Time.Posix"}],"binops":[]}]